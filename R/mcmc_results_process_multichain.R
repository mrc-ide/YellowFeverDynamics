# Functions relating to processing of Markov Chain Monte Carlo output data where multiple chains are considered
#-------------------------------------------------------------------------------
#' @title get_mcmc_datasets_multichain
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param input_folders Vector of folders to get chain data
#'
#' @export
#'
get_mcmc_datasets_multichain <- function(input_folders=c()){
  #TODO Add assert_that functions
  
  datasets=list()
  for(i in c(1:length(input_folders))){
    input_folder=input_folders[i]
    datasets[[i]] <- get_mcmc_data(input_folder,plot_graph=FALSE)
  }
  
  return(datasets)
}
#-------------------------------------------------------------------------------
#' @title display_multichain_progress
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param selection Vector of dataset numbers to be selected from list
#' @param burnin_values Vector of burnin values to use for selected datasets (set to 1 by default)
#' @param end_values Vector of end values to use for selected datasets (set to last value by default)
#' @param flag_diag2 TBA
#'
#' @export
#'
display_multichain_progress <- function(datasets=list(),selection=c(1),burnin_values=NULL,end_values=NULL,
                                        flag_diag2=FALSE){
  #TODO Add assert_that functions
  assert_that(is.logical(flag_diag2))
  if(is.null(burnin_values)==TRUE){burnin_values=rep(1,length(selection))} else {
    assert_that(length(selection)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(selection)){
      end_values[i]=length(input_frames[[selection[i]]]$posterior_current)
    }
  } else {
    assert_that(length(selection)==length(end_values))}
  
  rows=like_values=list()
  itmax=0
  like_min=0
  like_max=-10000
  mcmc_list=mcmc.list()
  for(i in 1:length(selection)){
    n_data=selection[i]
    rows[[i]]=c(burnin_values[i]:end_values[i])
    input_frame=input_frames[[n_data]]
    mcmc_list[[i]]=mcmc(data=input_frame[,c(3:(2+n_params))],start=burnin_values[i],
                         end=end_values[i],thin=1)
    like_values[[n_data]]=input_frame$posterior_current[rows[[i]]]
    like_values[[n_data]][is.infinite(like_values[[n_data]])]=-10000
    like_min=min(like_min,min(like_values[[n_data]]))
    like_max=max(like_max,max(like_values[[n_data]]))
  }
  diag1=gelman.diag(mcmc_list,autoburnin=FALSE)
  if(flag_diag2){diag2<-gelman.plot(mcmc_list,autoburnin=FALSE,ask=FALSE,bin.width=1000,max.bins=100)} else {diag2=NULL}
  title_text="Chains:"
  for(i in 1:length(selection)){title_text=paste(title_text,selection[i],sep=" ")}
  title_text=paste(title_text," - MPSRF = ",signif(diag1$mpsrf,4),sep="")
  matplot(x=c(1,max(end_values)),y=c(like_min,like_max),type="p",col=0,xlab="Iteration",ylab="LogLikelihood")
  for(i in 1:length(selection)){
    n_data=selection[i]
    matplot(x=rows[[i]],y=like_values[[n_data]],type="l",col=n_data,add=TRUE)
  }
  title(main=title_text)
  
  return(list(like_values=like_values,MPSRF=diag1$mpsrf,diag_all=diag2))
}