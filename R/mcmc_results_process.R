# Functions relating to processing of Markov Chain Monte Carlo output data
#-------------------------------------------------------------------------------
#' @title get_mcmc_params
#'
#' @description Identify columns in MCMC output data containing fitted parameter values and get parameter names
#'
#' @details This function takes in a dataset output by mcmc() and extracts the names of the fitted parameters as a
#'   vector
#'
#' @param chain Data frame containing MCMC output
#' '
#' @export
#'
get_mcmc_params <- function(chain=list()){

  assert_that(is.data.frame(chain))
  column_names=colnames(chain)
  assert_that("posterior_current" %in% column_names)
  assert_that("flag_accept" %in% column_names)

  if("posterior_prop" %in% column_names){n_start=3} else {n_start=2}
  n_end=match("flag_accept",column_names)-1
  columns=c(n_start:n_end)
  param_names=column_names[columns]

  return(param_names)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_data
#'
#' @description Read MCMC results from CSV files in folder; plot likelihood graph and/or output data set
#'
#' @details This function is intended to read the output of the mcmc() function saved as CSV files over the course of
#' a run. It reads all CSV files in specified folder (ignoring subfolders) in alphabetical order and combines them
#' into a single data frame. It  outputs the data frame and optionally plots the posterior likelihood on a graph.
#'
#' @param input_folder Folder containing CSV files output by mcmc()
#' @param plot_graph TRUE/FALSE flag indicating whether to plot graph of likelihood values
#' '
#' @export
#'
get_mcmc_data <- function(input_folder="",plot_graph=TRUE){

  assert_that(file.exists(input_folder),msg="Valid input folder must be specified")

  file_list=list.files(path=input_folder,pattern="*.csv")
  input_frame=data.frame()
  for(i in 1:length(file_list)){
    data=read.csv(paste(input_folder,file_list[i],sep="/"),header=TRUE)
    if(i==1){
      param_names=get_mcmc_params(data)
      columns=colnames(data) %in% c("posterior_current",param_names)
    }
    input_frame<-rbind(input_frame,data[,columns])
  }

  if(plot_graph==TRUE){
    matplot(x=c(1:nrow(input_frame)),y=input_frame$posterior_current,type="l",xlab="Iteration",ylab="LogLikelihood")}

  return(input_frame)
}
#-------------------------------------------------------------------------------
#' @title truncate_mcmc_data
#'
#' @description Take MCMC results generated by get_mcmc_data and extract selected lines; optionally plot likelihood
#' graph and/or output data set
#'
#' @details This function takes in a data frame output by the get_mcmc_data() function and outputs a data frame
#' consisting only of the selected lines; it can be used to cut off all pre-burnin points in the Markov chain and/or
#' to obtain a selection of points along part of the chain. A graph of the posterior likelihood values in the
#' truncated data frame can optionally be plotted.
#'
#' @param input_frame Data frame of output data
#' @param rows Vector of line numbers to extract from input_frame
#' @param plot_graph TRUE/FALSE flag indicating whether to plot results graph
#' '
#' @export
#'
truncate_mcmc_data <- function(input_frame=list(),rows=c(1),plot_graph=TRUE){
  assert_that(is.data.frame(input_frame))
  assert_that("posterior_current" %in% colnames(input_frame))
  assert_that(is.integer(rows))
  assert_that(is.logical(plot_graph))

  line_list=c(1:nrow(input_frame))
  input_frame <- cbind(input_frame,line_list)
  input_frame_truncated=input_frame[rows,]

  if(plot_graph==TRUE){matplot(x=rows,y=input_frame_truncated$posterior_current,
                               type="l",xlab="Iteration",ylab="LogLikelihood")}

  return(input_frame_truncated)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_FOI_R0_data
#'
#' @description Extract spillover force of infection (FOI) and reproduction number (R0) values from MCMC output data
#'
#' @details This function takes in a data frame produced by functions get_mcmc_data() and/or truncate_mcmc_data() and
#' calculates spillover force of infection (FOI) and reproduction number (R0) values for each row in the frame
#' (representing points on the chain) based on the type of fit carried out.
#'
#' @param input_frame Data frame of MCMC output data
#' @param type Type of parameter set (FOI only, FOI+R0, FOI and/or R0 coefficients associated with environmental
#'   covariates); choose from "FOI","FOI+R0","FOI enviro","FOI+R0 enviro"
#' @param enviro_data Data frame of environmental covariate values used to calculate FOI and R0 in MCMC run, by region
#'   (NOTE: the data frame should include only the relevant environmental covariates; any not used in the MCMC fit
#'    should be removed)
#' '
#' @export
#'
get_mcmc_FOI_R0_data <- function(input_frame=list(),type="FOI+R0",enviro_data=list()){
  assert_that(is.data.frame((input_frame)))
  assert_that(type %in% c("FOI","FOI+R0","FOI enviro","FOI+R0 enviro"))

  if("flag_accept" %in% colnames(input_frame)){param_names=get_mcmc_params(input_frame)} else {
    param_names=colnames(input_frame)[c(2:ncol(input_frame))]}
  columns=which(colnames(input_frame) %in% param_names)

  if(type %in% c("FOI enviro","FOI+R0 enviro")){
    assert_that(is.data.frame((enviro_data)))
    assert_that(all(enviro_data$region==sort(enviro_data$region)),
                msg="Regions in environmental data must be in alphabetical order")
    n_env_vars=ncol(enviro_data)-1
    env_vars=colnames(enviro_data)[c(2:(n_env_vars+1))]
    regions=enviro_data$region
    n_regions=length(regions)
  } else {
    n_regions=0
    for(i in 1:length(param_names)){
      prefix=substr(param_names[i],1,3)
      if(prefix=="FOI"){n_regions=n_regions+1}
    }
  }

  n_lines=nrow(input_frame)
  blank=rep(NA,n_regions*n_lines)
  output_frame=data.frame(n_region=as.factor(rep(c(1:n_regions),n_lines)),FOI=blank)
  if(type %in% c("FOI+R0","FOI+R0 enviro")){
    R0=blank
    output_frame=cbind(output_frame,R0)}

  if(type %in% c("FOI enviro","FOI+R0 enviro")){

    columns1=columns[c(1:n_env_vars)]
    output_frame$FOI=as.vector(as.matrix(enviro_data[,c(2:(n_env_vars+1))]) %*% t(as.matrix(input_frame[,columns1])))
    if(type=="FOI+R0 enviro"){
      columns2=columns[c(1:n_env_vars)]+n_env_vars
      output_frame$R0=as.vector(as.matrix(enviro_data[,c(2:(n_env_vars+1))]) %*% t(as.matrix(input_frame[,columns2])))
    }

  } else {
    output_frame$FOI=as.vector(t(as.matrix(input_frame[,columns[c(1:n_regions)]])))
    if(type=="FOI+R0"){output_frame$R0=as.vector(t(as.matrix(input_frame[,columns[c(1:n_regions)+n_regions]])))}
  }

  return(output_frame)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_enviro_coeff_data
#'
#' @description Extract values of environmental coefficients from MCMC output data
#'
#' @details This function takes in a data frame produced by functions get_mcmc_data() and/or truncate_mcmc_data() and
#' calculates spillover force of infection (FOI) and reproduction number (R0) values for each row in the frame
#' (representing points on the chain) based on the type of fit carried out.
#'
#' @param input_frame Data frame of MCMC output data
#' @param type Type of parameter set (FOI only, FOI+R0, FOI and/or R0 coefficients associated with environmental
#'   covariates); choose from "FOI enviro","FOI+R0 enviro"
#' @param enviro_data Data frame of environmental covariate values used to calculate FOI and R0 in MCMC run, by region
#'   (NOTE: the data frame should include only the relevant environmental covariates; any not used in the MCMC fit
#'    should be removed)
#' '
#' @export
#'
get_mcmc_enviro_coeff_data <- function(input_frame=list(),type="FOI+R0",enviro_data=list()){
  assert_that(is.data.frame((input_frame)))
  assert_that(type %in% c("FOI enviro","FOI+R0 enviro"))
  if(type %in% c("FOI enviro","FOI+R0 enviro")){
    assert_that(is.data.frame((enviro_data)))
    assert_that(all(enviro_data$region==sort(enviro_data$region)),
                msg="Regions in environmental data must be in alphabetical order")
  }

  if("flag_accept" %in% colnames(input_frame)){param_names=get_mcmc_params(input_frame)} else {
    param_names=colnames(input_frame)[c(2:ncol(input_frame))]}
  columns=which(colnames(input_frame) %in% param_names)

  n_lines=nrow(input_frame)
  n_env_vars=ncol(enviro_data)-1
  env_vars=colnames(enviro_data)[c(2:(n_env_vars+1))]

  blank=rep(NA,n_env_vars*n_lines)
  output_frame=data.frame(n_env_var=as.factor(rep(c(1:n_env_vars),n_lines)),env_var=blank,FOI_coeffs=blank)
  output_frame$env_var=env_vars[output_frame$n_env_var]
  if(type=="FOI+R0 enviro"){
    R0_coeffs=blank
    output_frame=cbind(output_frame,R0_coeffs)}

  columns1=columns[c(1:n_env_vars)]
  output_frame$FOI_coeffs=as.vector(t(input_frame[,columns1]))
  if(type=="FOI+R0 enviro"){
    columns2=columns[c(1:n_env_vars)]+n_env_vars
    output_frame$R0_coeffs=as.vector(t(input_frame[,columns2]))
  }

  return(output_frame)
}
#-------------------------------------------------------------------------------
#' @title plot_mcmc_FOI_R0_data
#'
#' @description Plot spillover force of infection (FOI) and reproduction number (R0) values from MCMC output data
#'
#' @details This function takes in a data frame of spillover force of infection (FOI) and reproduction number (R0)
#' values calculated from MCMC output data using the get_mcmc_FOI_R0_data() function and plots the values in one of a
#' number of different ways to display the spread of values obtained (box plots, violin plots, simple plots with error
#' bars, and scatter plots of FOI vs R0).
#'
#' @param data_frame Data frame of FOI/R0 values obtained using get_mcmc_FOI_R0_data()
#' @param regions List of region names
#' @param plot_type Type of plots to create (choose from "box","violin","error_bars","scatter")
#' @param text_size1 Text size parameter for axis labels
#' '
#' @export
#'
plot_mcmc_FOI_R0_data <- function(data_frame=list(),regions=c(),plot_type="box",text_size1=10.0){
  assert_that(is.data.frame((data_frame)))
  assert_that(is.character(regions))
  assert_that(is.numeric(text_size1))
  if(is.null(data_frame$R0)==TRUE){
    assert_that(plot_type %in% c("box","violin","error_bars"))
  } else {
    assert_that(plot_type %in% c("box","violin","error_bars","scatter"))
  }

  #TODO - Sort out region selection/labelling
  n_regions=length(regions)
  assert_that(n_regions==length(names(table(data_frame$n_region))))
  output_labels=rep(NA,n_regions)
  for(i in 1:n_regions){output_labels[i]=substr(regions[i],1,5)}

  FOI_labels=10^c(-10:1)
  n_region=NULL

  if(plot_type %in% c("box","violin")){
    FOI=NULL
    p_FOI <- ggplot(data=data_frame,aes(x=n_region,y=log(FOI))) + theme_bw()
    if(plot_type=="box"){
      p_FOI <- p_FOI+geom_boxplot(outlier.size = 0)
    } else {
      p_FOI <- p_FOI+geom_violin(trim=FALSE,scale="width")}
    p_FOI <- p_FOI + scale_x_discrete(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
    p_FOI <- p_FOI + scale_y_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    p_FOI <- p_FOI + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                           axis.text.y = element_text(size = text_size1),
                           axis.title.y = element_text(size = text_size1))

    if(is.null(data_frame$R0)==FALSE){
      R0=NULL
      p_R0 <- ggplot(data=data_frame,aes(x=n_region,y=R0)) + theme_bw()
      if(plot_type=="box"){
        p_R0 <- p_R0+geom_boxplot(outlier.size = 0)
      } else {
        p_R0 <- p_R0+geom_violin(trim=FALSE,scale="width")
      }
      p_R0 <- p_R0 + scale_x_discrete(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
      p_R0 <- p_R0 + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                           axis.text.y = element_text(size = text_size1),
                           axis.title.y = element_text(size = text_size1))
    } else {
      p_R0<-NULL
    }
    output<-list(p_FOI=p_FOI,p_R0=p_R0)
  }

  if(plot_type=="scatter"){
    p_FOI_R0 <- ggplot() + theme_bw()
    p_FOI_R0 <- p_FOI_R0 + scale_x_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    for(i in 1:n_regions){
      subset=data_frame[data_frame$n_region==i,]
      names(subset)[names(subset)=="n_region"]="Region"
      Region=NULL
      p_FOI_R0 <- p_FOI_R0 + geom_point(data=subset,aes(x=log(FOI),y=R0,colour=Region))
      p_FOI_R0 <- p_FOI_R0 + theme(axis.text.x = element_text(size = text_size1),
                                   axis.text.y = element_text(size = text_size1),
                                   axis.title.y = element_text(size = text_size1))
    }
    output<-list(p_FOI_R0=p_FOI_R0)
  }

  if(plot_type=="error_bars"){
    blank=rep(NA,n_regions)
    lower=upper=NULL
    summary_frame_FOI=data.frame(n_region=c(1:n_regions),mean=blank,lower=blank,upper=blank)
    if(is.null(data_frame$R0)==FALSE){summary_frame_R0=summary_frame_FOI}
    for(i in 1:n_regions){
      subset=data_frame[data_frame$n_region==i,]
      FOI_CI=exp(CI(log(subset$FOI)))
      summary_frame_FOI$mean[i]=FOI_CI[[2]]
      summary_frame_FOI$lower[i]=FOI_CI[[3]]
      summary_frame_FOI$upper[i]=FOI_CI[[1]]
      if(is.null(data_frame$R0)==FALSE){
        R0_CI=CI(subset$R0)
        summary_frame_R0$mean[i]=R0_CI[[2]]
        summary_frame_R0$lower[i]=R0_CI[[3]]
        summary_frame_R0$upper[i]=R0_CI[[1]]
      }
    }

    p_FOI <- ggplot(data=summary_frame_FOI,aes(x=n_region,y=log(mean))) + theme_bw()
    p_FOI <- p_FOI + scale_x_continuous(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
    p_FOI <- p_FOI + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                           axis.text.y = element_text(size = text_size1))
    p_FOI <- p_FOI + scale_y_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    p_FOI <- p_FOI + geom_line(data=summary_frame_FOI,aes(x=n_region,y=log(mean)))
    p_FOI <- p_FOI + geom_errorbar(data=summary_frame_FOI,aes(ymin=log(lower),ymax=log(upper)),width=0.5)

    if(is.null(data_frame$R0)==FALSE){
      p_R0 <- ggplot(data=summary_frame_R0,aes(x=n_region,y=mean)) + theme_bw()
      p_R0 <- p_R0 + scale_x_continuous(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
      p_R0 <- p_R0 + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                           axis.text.y = element_text(size = text_size1))
      p_R0 <- p_R0 + geom_line(data=summary_frame_R0,aes(x=n_region,y=mean))
      p_R0 <- p_R0 + geom_errorbar(data=summary_frame_R0,aes(ymin=lower,ymax=upper),width=0.5)
    } else {
      p_R0 <- NULL
    }
    output<-list(p_FOI=p_FOI,p_R0=p_R0)
  }

  return(output)
}
#-------------------------------------------------------------------------------
#' @title plot_mcmc_enviro_coeff_data
#'
#' @description Plot environmental coefficients from MCMC results
#'
#' @details This function takes in a data frame of values (obtained using the get_mcmc_enviro_coeff_data() function) of
#'   the coefficients of environmental covariates and plots them on graphs
#'
#' @param data_frame Data frame of coefficient values obtained using get_mcmc_enviro_coeff_data()
#' @param env_vars List of environmental covariates
#' @param plot_type Type of plots to create (choose from "box","violin")
#' @param text_size1 Text size parameter for axis labels
#' '
#' @export
#'
plot_mcmc_enviro_coeff_data <- function(data_frame=list(),env_vars=c(),plot_type="box",text_size1=10.0){
  assert_that(is.data.frame((data_frame)))
  assert_that(is.character(env_vars))
  assert_that(plot_type %in% c("box","violin"))
  assert_that(is.numeric(text_size1))

  #TODO - Sort out environmental covariate numbers/labelling
  n_env_vars=length(env_vars)
  assert_that(n_env_vars==length(names(table(data_frame$n_env_var))))

  FOI_limits=c(floor(log(min(data_frame$FOI_coeffs),10)),ceiling(log(max(data_frame$FOI_coeffs),10)))
  FOI_labels=10^c(FOI_limits[1]:FOI_limits[2])
  R0_limits=c(floor(log(min(data_frame$R0_coeffs),10)),ceiling(log(max(data_frame$R0_coeffs),10)))
  R0_labels=10^c(R0_limits[1]:R0_limits[2])
  n_env_var=NULL

  if(plot_type %in% c("box","violin")){
    FOI_coeffs=NULL
    p_FOI <- ggplot(data=data_frame,aes(x=n_env_var,y=log(FOI_coeffs,10))) + theme_bw()
    if(plot_type=="box"){
      p_FOI <- p_FOI+geom_boxplot(outlier.size = 0)
    } else {
      p_FOI <- p_FOI+geom_violin(trim=FALSE,scale="width")}
    p_FOI <- p_FOI + scale_x_discrete(name="",breaks=c(1:n_env_vars),labels=env_vars)
    p_FOI <- p_FOI + scale_y_continuous(name="FOI coefficients",breaks=log(FOI_labels,10),labels=FOI_labels,
                                        limits=FOI_limits)
    p_FOI <- p_FOI + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                           axis.text.y = element_text(size = text_size1),
                           axis.title.y = element_text(size = text_size1))

    if(is.null(data_frame$R0_coeffs)==FALSE){
      R0_coeffs=NULL
      p_R0 <- ggplot(data=data_frame,aes(x=n_env_var,y=log(R0_coeffs,10))) + theme_bw()
      if(plot_type=="box"){
        p_R0 <- p_R0+geom_boxplot(outlier.size = 0)
      } else {
        p_R0 <- p_R0+geom_violin(trim=FALSE,scale="width")
      }
      p_R0 <- p_R0 + scale_x_discrete(name="",breaks=c(1:n_env_vars),labels=env_vars)
      p_R0 <- p_R0 + scale_y_continuous(name="R0 coefficients",breaks=log(R0_labels,10),labels=R0_labels,
                                        limits=R0_limits)
      p_R0 <- p_R0 + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                           axis.text.y = element_text(size = text_size1),
                           axis.title.y = element_text(size = text_size1))
    } else {
      p_R0<-NULL
    }
    output<-list(p_FOI=p_FOI,p_R0=p_R0)
  }

  return(output)
}
#-------------------------------------------------------------------------------
#' @title plot_mcmc_prob_data
#'
#' @description Plot values of vaccine efficacy and/or reporting probabilities from MCMC output data
#'
#' @details This function takes in a data frame produced by functions get_mcmc_data() and/or truncate_mcmc_data(),
#' calculates the values of additional parameters fitted using the function besides spillover force of infection (FOI)
#' and reproduction number (R0) plots the values in one of a number of different ways to display the spread of values
#' obtained (box plots, violin plots, simple plots with error bars).
#'
#' @param input_frame Data frame of MCMC output data
#' @param plot_type Type of plots to create (choose from "box","violin","error_bars")
#' @param values List of names of parameters to plot (must be parameters appearing in the data)
#' @param text_size1 Text size parameter for axis labels
#'
#' @export
#'
plot_mcmc_prob_data <- function(input_frame=list(),plot_type="box",values=c("vaccine_efficacy"),text_size1=10.0){
  assert_that(is.data.frame((input_frame)))
  assert_that(plot_type %in% c("box","violin","error_bars"))
  assert_that(is.character(values))
  assert_that(is.numeric(text_size1))

  #TODO - Sort out variable naming/numbers
  n_values=length(values)
  for(i in 1:n_values){assert_that(values[i] %in% colnames(input_frame))}

  data<-input_frame[,colnames(input_frame) %in% values]
  n_lines=nrow(input_frame)
  labels=c(0.001,0.005,0.01,0.05,0.1,0.5,1.0)
  output_frame=data.frame(n_param=as.factor(rep(c(1:n_values),n_lines)),p=rep(NA,n_values*n_lines))
  for(i in 1:n_lines){
    output_lines=((i-1)*n_values)+c(1:n_values)
    output_frame$p[output_lines]=as.numeric(data[i,])
  }

  if(plot_type %in% c("box","violin")){
    n_param=p=NULL
    p_probs <- ggplot(data=output_frame,aes(x=n_param,y=log(p))) + theme_bw()
    if(plot_type=="box"){
      p_probs <- p_probs+geom_boxplot(outlier.size=0)
    } else {
      p_probs <- p_probs+geom_violin(trim=FALSE,scale="width")}
    p_probs <- p_probs + scale_x_discrete(name="",breaks=c(1:length(values)),labels=values)
    p_probs <- p_probs + scale_y_continuous(name="",breaks=log(labels),labels=labels)
    p_probs <- p_probs + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                               axis.text.y = element_text(size = text_size1),
                               axis.title.y = element_text(size = text_size1))
  }
  if(plot_type=="error_bars"){
    blank=rep(NA,n_values)
    lower=upper=NULL
    summary_frame=data.frame(n_value=c(1:n_values),mean=blank,lower=blank,upper=blank)
    for(i in 1:n_values){
      subset=subset(output_frame,as.numeric(output_frame$n_param)==i)
      probs_CI=CI(subset$p)
      summary_frame$mean[i]=probs_CI[[2]]
      summary_frame$lower[i]=probs_CI[[3]]
      summary_frame$upper[i]=probs_CI[[1]]
    }
    n_value=NULL
    p_probs <- ggplot(data=summary_frame,aes(x=n_value,y=log(mean))) + theme_bw()
    p_probs <- p_probs + scale_x_continuous(name="",breaks=c(1:n_values),labels=values)
    p_probs <- p_probs + scale_y_continuous(name="",breaks=log(labels),labels=labels)
    p_probs <- p_probs + geom_line(data=summary_frame,aes(x=n_value,y=log(mean)))
    p_probs <- p_probs + geom_errorbar(data=summary_frame,aes(ymin=log(lower),ymax=log(upper)),width=0.5)
    p_probs <- p_probs + theme(axis.text.x = element_text(angle = 90, hjust=1,size=text_size1),
                               axis.text.y = element_text(size = text_size1),
                               axis.title.y = element_text(size = text_size1))

  }

  return(p_probs)
}
