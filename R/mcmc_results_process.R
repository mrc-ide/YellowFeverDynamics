# R file for functions relating to processing of Markov Chain Monte Carlo output data in YellowFeverDynamics package
#-------------------------------------------------------------------------------
#' @title get_mcmc_data
#'
#' @description Read MCMC results from CSV files in folder; plot likelihood graph and/or output data set
#'
#' @details TBA
#'
#' @param input_folder Folder containing CSV files output by mcmc()
#' @param plot_graph TRUE/FALSE flag indicating whether to plot results graph
#' @param output_data TRUE/FALSE flag indicating whether to output results as data frame
get_mcmc_data <- function(input_folder="",plot_graph=TRUE,output_data=TRUE){
  assert_that(file.exists(input_folder))
  setwd(input_folder)

  file_list=list.files(pattern="*.csv")
  input_frame=data.frame()
  for(i in 1:length(file_list)){
    data=read.csv(file_list[i],header=TRUE)
    input_frame<-rbind(input_frame,data)
  }

  if(plot_graph==TRUE){
    matplot(x=c(1:nrow(input_frame)),y=input_frame$posterior_current,type="l",xlab="Iteration",ylab="LogLikelihood")}

  if(output_data==TRUE){return(input_frame)} else {return(NULL)}
}
#-------------------------------------------------------------------------------
#' @title truncate_mcmc_data
#'
#' @description Take MCMC results generated by get_mcmc_data and extract selected lines; optionally plot likelihood
#' graph and/or output data set
#'
#' @details TBA
#'
#' @param input_frame Data frame of output data
#' @param selection Vector of line numbers to extract from input_frame
#' @param plot_graph TRUE/FALSE flag indicating whether to plot results graph
#' @param output_data TRUE/FALSE flag indicating whether to output results as data frame
truncate_mcmc_data <- function(input_frame=list(),selection=c(1),plot_graph=TRUE,output_data=TRUE){
  assert_that(is.data.frame(input_frame))
  assert_that(is.integer(selection))

  line_list=c(1:nrow(input_frame))
  input_frame <- cbind(input_frame,line_list)
  input_frame_truncated=input_frame[selection,]

  if(plot_graph==TRUE){matplot(x=selection,y=input_frame_truncated$posterior_current,
                               type="l",xlab="Iteration",ylab="LogLikelihood")}

  if(output_data==TRUE){return(input_frame_truncated)} else {return(NULL)}
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_FOI_R0_data
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param input_frame TBA
#' @param type TBA
#' @param enviro_data TBA - Add note that enviro_data should include ONLY relevant environmental variables and regions
#' @param plot_type TBA
get_mcmc_FOI_R0_data <- function(input_frame=list(),type="FOI+R0",enviro_data=list(),plot_type="none"){
  #TODO - Add assertthat checks
  assert_that(type %in% c("FOI","FOI+R0","FOI enviro","FOI+R0 enviro"))
  assert_that(plot_type %in% c("box","violin","none"))

  n_lines=nrow(input_frame)
  n_env_vars=ncol(enviro_data)-1
  env_vars=colnames(enviro_data)[c(2:(n_env_vars+1))]
  regions=enviro_data$adm1
  n_regions=length(regions)
  blank=rep(NA,n_regions*n_lines)
  output_frame=data.frame(n_region=as.factor(rep(c(1:n_regions),n_lines)),FOI=blank)
  if(type %in% c("FOI+R0","FOI+R0 enviro")){
    R0=blank
    output_frame=cbind(output_frame,R0)}

  if(type %in% c("FOI enviro","FOI+R0 enviro")){
    if(type=="FOI enviro"){n_params=n_env_vars}
    if(type=="FOI+R0 enviro"){n_params=2*n_env_vars}
    line0=-Inf
    for(j in 1:n_lines){
      line1=input_frame$line_list[j]
      output_lines=((j-1)*n_regions)+c(1:n_regions)
      if(j>1 && line1==line0+1 && input_frame$flag_accept[j]==0){
        output_frame$FOI[output_lines]=output_frame$FOI[output_lines-n_regions]
        if(type == "FOI+R0 enviro"){output_frame$R0[output_lines]=output_frame$R0[output_lines-n_regions]}
        output_frame$FOI[output_lines]=output_frame$FOI[output_lines-n_regions]
      } else {
        params=input_frame[j,c(3:(n_params+2))]
        FOI=R0=rep(0,n_regions)
        for(n_region in 1:n_regions){
          variable_values=enviro_data[n_region,c(2:(n_env_vars+1))]
          FOI[n_region]=sum(variable_values*params[c(1:n_env_vars)])
          if(type == "FOI+R0 enviro"){R0[n_region]=sum(variable_values*params[c(1:n_env_vars)+n_env_vars])}
        }
        output_frame$FOI[output_lines]=FOI
        if(type == "FOI+R0 enviro"){output_frame$R0[output_lines]=R0}
      }
      line0=line1
    }
  } else {
    for(j in 1:n_lines){
      output_lines=((j-1)*n_regions)+c(1:n_regions)
      output_frame$FOI[output_lines]=as.numeric(input_frame[j,c(3:(n_regions+2))])
      if(type=="FOI+R0"){output_frame$R0[output_lines]=as.numeric(input_frame[j,c((n_regions+3):((2*n_regions)+2))])}
    }
  }

  if(plot_type %in% c("box","violin")){
    plot_mcmc_FOI_R0_data(output_frame,regions,plot_type)
  }

  return(output_frame)
}
#-------------------------------------------------------------------------------
#' @title plot_mcmc_FOI_R0_data
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param data_frame TBA
#' @param regions TBA
#' @param plot_type TBA
#' @param margin TBA
plot_mcmc_FOI_R0_data <- function(data_frame,regions,plot_type="box",margin=0.95){
  #TODO - Add assertthat checks
  if(is.null(data_frame$R0)==TRUE){
    assert_that(plot_type %in% c("box","violin","error_bars"))
  } else {
    assert_that(plot_type %in% c("box","violin","error_bars","scatter"))
  }

  n_regions=length(regions)
  output_labels=rep(NA,n_regions)
  for(i in 1:n_regions){output_labels[i]=substr(regions[i],1,5)}

  par(mar=c(4,4,2,2))
  FOI_labels=10^c(-10:1)

  if(plot_type %in% c("box","violin")){
    p_FOI <- ggplot(data=data_frame,aes(x=~n_region,y=log(~FOI))) + theme_bw()
    if(plot_type=="box"){p_FOI <- p_FOI+geom_boxplot(outlier.size = 0)} else {p_FOI <- p_FOI+geom_violin(trim=FALSE)}
    p_FOI <- p_FOI + scale_x_discrete(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
    p_FOI <- p_FOI + scale_y_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    p_FOI <- p_FOI + theme(axis.text.x = element_text(angle = 90, hjust=1))

    if(is.null(data_frame$R0)==FALSE){
      p_R0 <- ggplot(data=data_frame,aes(x=~n_region,y=~R0)) + theme_bw()
      if(plot_type=="box"){p_R0 <- p_R0+geom_boxplot(outlier.size = 0)} else {p_R0 <- p_R0+geom_violin(trim=FALSE)}
      p_R0 <- p_R0 + scale_x_discrete(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
      p_R0 <- p_R0 + theme(axis.text.x = element_text(angle = 90, hjust=1))
    } else {
      p_R0<-NULL
    }
    output<-list(p_FOI=p_FOI,p_R0=p_R0)
  }

  if(plot_type=="scatter"){
    p_FOI_R0 <- ggplot() + theme_bw()
    p_FOI_R0 <- p_FOI_R0 + scale_x_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    for(i in 1:n_regions){
      subset=data_frame[data_frame$n_region==i,]
      names(subset)[names(subset)=="n_region"]="Region"
      p_FOI_R0 <- p_FOI_R0 + geom_point(data=subset,aes(x=log(~FOI),y=~R0,colour=~Region))
    }
    output<-list(p_FOI_R0=p_FOI_R0)
  }

  if(plot_type=="error_bars"){
    blank=rep(NA,n_regions)
    summary_frame_FOI=data.frame(n_region=c(1:n_regions),median=blank,lower=blank,upper=blank)
    p_lower=ceiling((0.5*(1.0-margin)*nrow(data_frame))/n_regions)
    p_upper=floor(((margin+(0.5*(1.0-margin)))*nrow(data_frame))/n_regions)
    if(is.null(data_frame$R0)==FALSE){summary_frame_R0=summary_frame_FOI}
    for(i in 1:n_regions){
      subset=data_frame[data_frame$n_region==i,]
      FOI_sorted=sort(subset$FOI)
      summary_frame_FOI$median[i]=median(FOI_sorted)
      summary_frame_FOI$lower[i]=FOI_sorted[p_lower]
      summary_frame_FOI$upper[i]=FOI_sorted[p_upper]
      if(is.null(data_frame$R0)==FALSE){
        R0_sorted=sort(subset$R0)
        summary_frame_R0$median[i]=median(R0_sorted)
        summary_frame_R0$lower[i]=R0_sorted[p_lower]
        summary_frame_R0$upper[i]=R0_sorted[p_upper]
      }
    }

    p_FOI <- ggplot(data=summary_frame_FOI,aes(x=~n_region,y=log(~median))) + theme_bw()
    p_FOI <- p_FOI + scale_x_continuous(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
    p_FOI <- p_FOI + theme(axis.text.x = element_text(angle = 90, hjust=1))
    p_FOI <- p_FOI + scale_y_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    p_FOI <- p_FOI + geom_line(data=summary_frame_FOI,aes(x=~n_region,y=log(~median)))
    p_FOI <- p_FOI + geom_errorbar(data=summary_frame_FOI,aes(ymin=log(~lower),ymax=log(~upper)),width=0.5)

    if(is.null(data_frame$R0)==FALSE){
      p_R0 <- ggplot(data=summary_frame_R0,aes(x=~n_region,y=~median)) + theme_bw()
      p_R0 <- p_R0 + scale_x_continuous(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
      p_R0 <- p_R0 + theme(axis.text.x = element_text(angle = 90, hjust=1))
      p_R0 <- p_R0 + geom_line(data=summary_frame_R0,aes(x=~n_region,y=~median))
      p_R0 <- p_R0 + geom_errorbar(data=summary_frame_R0,aes(ymin=~lower,ymax=~upper),width=0.5)
    } else {
      p_R0 <- NULL
    }
    output<-list(p_FOI=p_FOI,p_R0=p_R0)
  }

  return(output)
}
#-------------------------------------------------------------------------------
#' @title plot_mcmc_prob_data
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param input_frame TBA
#' @param plot_type TBA
#' @param values TBA
#' @param margin TBA
plot_mcmc_prob_data <- function(input_frame,plot_type="box",values=c("vacc_eff"),margin=0.95){
  assert_that(plot_type %in% c("box","violin","error_bars"))

  n_values=length(values)
  for(i in 1:n_values){assert_that(values[i] %in% colnames(input_frame))}

  data<-input_frame[,colnames(input_frame) %in% values]
  n_lines=nrow(input_frame)
  labels=c(0.001,0.005,0.01,0.05,0.1,0.5,1.0)
  output_frame=data.frame(n_param=as.factor(rep(c(1:n_values),n_lines)),p=rep(NA,n_values*n_lines))
  for(i in 1:n_lines){
    output_lines=((i-1)*n_values)+c(1:n_values)
    output_frame$p[output_lines]=as.numeric(data[i,])
  }

  par(mar=c(4,4,2,2))

  if(plot_type %in% c("box","violin")){
    p_probs <- ggplot(data=output_frame,aes(x=~n_param,y=log(~p))) + theme_bw()
    if(plot_type=="box"){
      p_probs <- p_probs+geom_boxplot(outlier.size=0)
    } else {
      p_probs <- p_probs+geom_violin(trim=FALSE)}
    p_probs <- p_probs + scale_x_discrete(name="",breaks=c(1:length(values)),labels=values)
    p_probs <- p_probs + scale_y_continuous(name="",breaks=log(labels),labels=labels)
    p_probs <- p_probs + theme(axis.text.x = element_text(angle = 90, hjust=1))
  }
  if(plot_type=="error_bars"){
    blank=rep(NA,n_values)
    p_lower=ceiling((0.5*(1.0-margin)*nrow(output_frame))/n_values)
    p_upper=floor(((margin+(0.5*(1.0-margin)))*nrow(output_frame))/n_values)
    summary_frame=data.frame(n_value=c(1:n_values),median=blank,lower=blank,upper=blank)
    for(i in 1:n_values){
      subset=subset(output_frame,as.numeric(~n_param)==i)
      probs_sorted=sort(subset$p)
      summary_frame$median[i]=median(probs_sorted)
      summary_frame$lower[i]=probs_sorted[p_lower]
      summary_frame$upper[i]=probs_sorted[p_upper]
    }
    p_probs <- ggplot(data=summary_frame,aes(x=~n_value,y=log(~median))) + theme_bw()
    p_probs <- p_probs + scale_x_continuous(name="",breaks=c(1:n_values),labels=values)
    p_probs <- p_probs + scale_y_continuous(name="",breaks=log(labels),labels=labels)
    p_probs <- p_probs + geom_line(data=summary_frame,aes(x=~n_value,y=log(~median)))
    p_probs <- p_probs + geom_errorbar(data=summary_frame,aes(ymin=log(~lower),ymax=log(~upper)),width=0.5)
    p_probs <- p_probs + theme(axis.text.x = element_text(angle = 90, hjust=1))

  }

  return(p_probs)
}
