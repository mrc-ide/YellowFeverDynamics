# Functions relating to processing of Markov Chain Monte Carlo output data where multiple chains are considered
#-------------------------------------------------------------------------------
#' @title get_mcmc_datasets_multichain
#'
#' @description Get MCMC output data from multiple chains
#'
#' @details TBA
#'
#' @param input_folders Vector of folders to get chain data
#'
#' @export
#'
get_mcmc_datasets_multichain <- function(input_folders=c()){
  #TODO Add assert_that functions

  datasets=list()
  for(i in c(1:length(input_folders))){
    input_folder=input_folders[i]
    datasets[[i]] <- get_mcmc_data(input_folder,plot_graph=FALSE)
  }

  return(datasets)
}
#-------------------------------------------------------------------------------
#' @title display_multichain_progress
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param datasets_selected Vector of dataset numbers to be selected from list
#' @param burnin_values Vector of burnin values to use for selected datasets (set to 1 by default)
#' @param end_values Vector of end values to use for selected datasets (set to last value by default)
#' @param flag_diag2 TBA
#'
#' @export
#'
display_multichain_progress <- function(datasets=list(),datasets_selected=c(1),burnin_values=NULL,end_values=NULL,
                                        flag_diag2=FALSE){
  #TODO Add assert_that functions
  assert_that(is.logical(flag_diag2))
  if(is.null(burnin_values)==TRUE){burnin_values=rep(1,length(datasets_selected))} else {
    assert_that(length(datasets_selected)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(datasets_selected)){
      end_values[i]=length(datasets[[datasets_selected[i]]]$posterior_current)
    }
  } else {
    assert_that(length(datasets_selected)==length(end_values))}

  rows=like_values=list()
  itmax=0
  like_min=0
  like_max=-10000
  mcmc_list=mcmc.list()
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    rows[[i]]=c(burnin_values[i]:end_values[i])
    input_frame=datasets[[n_data]]
    if("flag_accept" %in% colnames(input_frame)){param_names=get_mcmc_params(input_frame)} else {
      param_names=colnames(input_frame)[c(2:ncol(input_frame))]}
    columns=which(colnames(input_frame) %in% param_names)

    mcmc_list[[i]]=mcmc(data=input_frame[,columns],start=burnin_values[i],
                         end=end_values[i],thin=1)
    like_values[[n_data]]=input_frame$posterior_current[rows[[i]]]
    like_values[[n_data]][is.infinite(like_values[[n_data]])]=-10000
    like_min=min(like_min,min(like_values[[n_data]]))
    like_max=max(like_max,max(like_values[[n_data]]))
  }
  diag1=gelman.diag(mcmc_list,autoburnin=FALSE)
  if(flag_diag2){diag2<-gelman.plot(mcmc_list,autoburnin=FALSE,ask=FALSE,bin.width=1000,max.bins=100)} else {diag2=NULL}
  title_text="Chains:"
  for(i in 1:length(datasets_selected)){title_text=paste(title_text,datasets_selected[i],sep=" ")}
  title_text=paste(title_text," - MPSRF = ",signif(diag1$mpsrf,4),sep="")
  matplot(x=c(1,max(end_values)),y=c(like_min,like_max),type="p",col=0,xlab="Iteration",ylab="LogLikelihood")
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    matplot(x=rows[[i]],y=like_values[[n_data]],type="l",col=n_data,add=TRUE)
  }
  title(main=title_text)

  return(list(like_values=like_values,MPSRF=diag1$mpsrf,diag_all=diag2))
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_FOI_R0_multichain
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param datasets_selected Vector of dataset numbers to be selected from list
#' @param burnin_values TBA
#' @param end_values TBA
#' @param type TBA
#' @param enviro_data TBA
#'
#' @export
#'
get_mcmc_FOI_R0_multichain <- function(datasets=c(),datasets_selected=c(1),burnin_values=NULL,end_values=NULL,
                                       type="FOI+R0",enviro_data=NULL){
  #TODO Add assert_that functions
  if(is.null(burnin_values)==TRUE){burnin_values=rep(1,length(datasets_selected))} else {
    assert_that(length(datasets_selected)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(datasets_selected)){
      end_values[i]=length(datasets[[datasets_selected[i]]]$posterior_current)
    }
  } else {
    assert_that(length(datasets_selected)==length(end_values))}

  outputs=list()
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    lines_selected=as.integer(burnin_values[i]+c(0:(end_values[i]-burnin_values[i])))
    outputs[[i]]=get_mcmc_FOI_R0_data(datasets[[n_data]][lines_selected,],type,enviro_data)
  }

  return(outputs)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_probs_multichain
#'
#' @description TBA
#'
#' @details TBA
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param datasets_selected Vector of dataset numbers to be selected from list
#' @param burnin_values TBA
#' @param end_values TBA
#' @param prob_names TBA
#'
#' @export
#'
get_mcmc_probs_multichain <- function(datasets=c(),datasets_selected=c(1),burnin_values=NULL,end_values=NULL,
                                      prob_names=c("vaccine_efficacy")){
  #TODO Add assert_that functions
  if(is.null(burnin_values)==TRUE){burnin_values=rep(1,length(datasets_selected))} else {
    assert_that(length(datasets_selected)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(datasets_selected)){
      end_values[i]=length(datasets[[datasets_selected[i]]]$posterior_current)
    }
  } else {
    assert_that(length(datasets_selected)==length(end_values))}

  outputs=list()
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    lines_selected=as.integer(burnin_values[i]+c(0:(end_values[i]-burnin_values[i])))
    outputs[[i]]=datasets[[n_data]][lines_selected,colnames(datasets[[n_data]]) %in% prob_names]
  }

  return(outputs)
}
