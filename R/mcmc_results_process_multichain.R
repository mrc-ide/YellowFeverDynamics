# Functions relating to processing of Markov Chain Monte Carlo output data where multiple chains are considered
#-------------------------------------------------------------------------------
#' @title get_mcmc_datasets_multichain
#'
#' @description Get MCMC output data from multiple chains
#'
#' @details This function extracts data produced by mcmc() and its subordinate functions and organizes them into
#'   a list of datasets for further processing.
#'
#' @param input_folders Vector of folders to get chain data
#'
#' @export
#'
get_mcmc_datasets_multichain <- function(input_folders=c()){
  assert_that(is.character(input_folders))

  datasets=list()
  for(i in c(1:length(input_folders))){
    input_folder=input_folders[i]
    datasets[[i]] <- get_mcmc_data(input_folder,plot_graph=FALSE)
  }

  return(datasets)
}
#-------------------------------------------------------------------------------
#' @title display_multichain_progress
#'
#' @description Plot graph of Markov chain progress
#'
#' @details This function plots a graph based on one or more datasets generated by get_mcm_datasets_multichain(),
#'   showing the likelihood as a function of the number of iterations
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param datasets_selected Vector of dataset numbers to be selected from list
#' @param burnin_values Vector of burnin values to use for selected datasets (set to 1 by default)
#' @param end_values Vector of end values to use for selected datasets (set to last value by default)
#' @param flag_grb Flag indicating whether to calculate Gelman-Rubin-Brooks convergence metric (MPSRF)
#' @param grb_plot Flag indicating whether to plot Gelman-Rubin-Brooks convergence diagnostic (coda::gelman.plot())
#'
#' @export
#'
display_multichain_progress <- function(datasets=list(),datasets_selected=c(1),burnin_values=NULL,end_values=NULL,
                                        flag_grb=TRUE,grb_plot=FALSE){
  assert_that(is.list(datasets))
  assert_that(is.numeric(datasets_selected))
  assert_that(all(datasets_selected %in% c(1:length(datasets))))
  assert_that(is.logical(flag_grb))
  assert_that(is.logical(grb_plot))
  if(is.null(burnin_values)==TRUE){
    burnin_values=rep(1,length(datasets_selected))
  } else {
    assert_that(length(datasets_selected)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(datasets_selected)){
      end_values[i]=length(datasets[[datasets_selected[i]]]$posterior_current)
    }
  } else {
    assert_that(length(datasets_selected)==length(end_values))}

  rows=like_values=list()
  itmax=0
  like_min=0
  like_max=-10000
  mcmc_list=mcmc.list()
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    rows[[i]]=c(burnin_values[i]:end_values[i])
    input_frame=datasets[[n_data]]
    if("flag_accept" %in% colnames(input_frame)){param_names=get_mcmc_params(input_frame)} else {
      param_names=colnames(input_frame)[c(2:ncol(input_frame))]}
    columns=which(colnames(input_frame) %in% param_names)

    mcmc_list[[i]]=mcmc(data=input_frame[,columns],start=burnin_values[i],end=end_values[i],thin=1)
    like_values[[n_data]]=input_frame$posterior_current[rows[[i]]]
    like_values[[n_data]][is.infinite(like_values[[n_data]])]=-10000
    like_min=min(like_min,min(like_values[[n_data]]))
    like_max=max(like_max,max(like_values[[n_data]]))
  }
  if(length(datasets_selected)>1 && flag_grb==TRUE){
    diag1=gelman.diag(mcmc_list,autoburnin=FALSE)
    MPSRF=signif(diag1$mpsrf,4)
  } else {MPSRF=NA}
  if(grb_plot){diag2<-gelman.plot(mcmc_list,autoburnin=FALSE,ask=FALSE,bin.width=1000,max.bins=100)} else {diag2=NULL}
  title_text="Chains:"
  for(i in 1:length(datasets_selected)){title_text=paste(title_text,datasets_selected[i],sep=" ")}
  title_text=paste(title_text," - MPSRF = ",MPSRF,sep="")
  matplot(x=c(1,max(end_values)),y=c(like_min,like_max),type="p",col=0,xlab="Iteration",ylab="LogLikelihood")
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    matplot(x=rows[[i]],y=like_values[[n_data]],type="l",col=n_data,add=TRUE)
  }
  title(main=title_text)

  return(list(like_values=like_values,MPSRF=MPSRF,diag_all=diag2))
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_FOI_R0_multichain
#'
#' @description Get FOI and R0 data from MCMC results
#'
#' @details This function extracts spillover FOI and R0 values from datasets generated by
#'   get_mcmc_datasets_multichain(), returning a list of datasets
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param datasets_selected Vector of dataset numbers to be selected from list
#' @param burnin_values Vector of burn-in iteration values (1 per dataset) before which data discarded
#' @param end_values Vector of end iteration values (1 per dataset) before which data discarded
#' @param type Type of parameter set (FOI only, FOI+R0, FOI and/or R0 coefficients associated with environmental
#'   covariates); choose from "FOI","FOI+R0","FOI enviro","FOI+R0 enviro"
#' @param enviro_data Data frame containing values of environmental covariates; set to NULL if not in use
#'
#' @export
#'
get_mcmc_FOI_R0_multichain <- function(datasets=c(),datasets_selected=c(1),burnin_values=NULL,end_values=NULL,
                                       type="FOI+R0",enviro_data=NULL){
  assert_that(is.list(datasets))
  assert_that(is.numeric(datasets_selected))
  assert_that(all(datasets_selected %in% c(1:length(datasets))))
  assert_that(all(enviro_data$region==sort(enviro_data$region)))
  if(is.null(burnin_values)==TRUE){
    burnin_values=rep(1,length(datasets_selected))
  } else {
    assert_that(length(datasets_selected)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(datasets_selected)){
      end_values[i]=length(datasets[[datasets_selected[i]]]$posterior_current)
    }
  } else {
    assert_that(length(datasets_selected)==length(end_values))}

  outputs=list()
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    lines_selected=as.integer(burnin_values[i]+c(0:(end_values[i]-burnin_values[i])))
    outputs[[i]]=get_mcmc_FOI_R0_data(datasets[[n_data]][lines_selected,],type,enviro_data)
  }

  return(outputs)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_enviro_coeff_multichain
#'
#' @description Get environmental coefficient data from MCMC results
#'
#' @details This function extracts values of the coefficients of environmental covariates from datasets
#'   generated by get_mcmc_datasets_multichain(), returning a list of datasets
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param datasets_selected Vector of dataset numbers to be selected from list
#' @param burnin_values Vector of burn-in iteration values (1 per dataset) before which data discarded
#' @param end_values Vector of end iteration values (1 per dataset) before which data discarded
#' @param type Type of parameter set (FOI only, FOI+R0, FOI and/or R0 coefficients associated with environmental
#'   covariates); choose from "FOI","FOI+R0","FOI enviro","FOI+R0 enviro"
#' @param enviro_data Data frame containing values of environmental covariates; set to NULL if not in use
#'
#' @export
#'
get_mcmc_enviro_coeff_multichain <- function(datasets=c(),datasets_selected=c(1),burnin_values=NULL,end_values=NULL,
                                       type="FOI+R0",enviro_data=NULL){
  assert_that(is.list(datasets))
  assert_that(is.numeric(datasets_selected))
  assert_that(all(datasets_selected %in% c(1:length(datasets))))
  if(is.null(burnin_values)==TRUE){
    burnin_values=rep(1,length(datasets_selected))
  } else {
    assert_that(length(datasets_selected)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(datasets_selected)){
      end_values[i]=length(datasets[[datasets_selected[i]]]$posterior_current)
    }
  } else {
    assert_that(length(datasets_selected)==length(end_values))}

  outputs=list()
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    lines_selected=as.integer(burnin_values[i]+c(0:(end_values[i]-burnin_values[i])))
    outputs[[i]]=get_mcmc_enviro_coeff_data(datasets[[n_data]][lines_selected,],type,enviro_data)
  }

  return(outputs)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_probs_multichain
#'
#' @description Get case reporting and vaccine efficacy data from MCMC results
#'
#' @details This function extracts values (where included in calculations) of the probabilities of severe and fatal
#'   cases being reported and the vaccine efficacy from datasets generated by get_mcmc_datasets_multichain(),
#'   returning a list of datasets
#'
#' @param datasets List containing one or more datasets, generated by get_mcmc_datasets_multichain()
#' @param datasets_selected Vector of dataset numbers to be selected from list
#' @param burnin_values Vector of burn-in iteration values (1 per dataset) before which data discarded
#' @param end_values Vector of end iteration values (1 per dataset) before which data discarded
#' @param prob_names Vector of names of probabilities to be extracted
#'
#' @export
#'
get_mcmc_probs_multichain <- function(datasets=c(),datasets_selected=c(1),burnin_values=NULL,end_values=NULL,
                                      prob_names=c("vaccine_efficacy")){
  assert_that(is.list(datasets))
  assert_that(is.numeric(datasets_selected))
  assert_that(all(datasets_selected %in% c(1:length(datasets))))
  if(is.null(burnin_values)==TRUE){
    burnin_values=rep(1,length(datasets_selected))
  } else {
    assert_that(length(datasets_selected)==length(burnin_values))}
  if(is.null(end_values)==TRUE){
    for(i in 1:length(datasets_selected)){
      end_values[i]=length(datasets[[datasets_selected[i]]]$posterior_current)
    }
  } else {
    assert_that(length(datasets_selected)==length(end_values))}

  outputs=list()
  for(i in 1:length(datasets_selected)){
    n_data=datasets_selected[i]
    lines_selected=as.integer(burnin_values[i]+c(0:(end_values[i]-burnin_values[i])))
    outputs[[i]]=datasets[[n_data]][lines_selected,colnames(datasets[[n_data]]) %in% prob_names]
  }

  return(outputs)
}
