# Functions relating to processing of Markov Chain Monte Carlo output data
#-------------------------------------------------------------------------------
#' @title get_mcmc_data
#'
#' @description Read MCMC results from CSV files in folder; plot likelihood graph and/or output data set
#'
#' @details This function is intended to read the output of the mcmc() function saved as CSV files over the course of
#' a run. It reads all CSV files in specified folder (ignoring subfolders) in alphabetical order and combines them
#' into a single data frame. It  outputs the data frame and optionally plots the posterior likelihood on a graph.
#'
#' @param input_folder Folder containing CSV files output by mcmc()
#' @param plot_graph TRUE/FALSE flag indicating whether to plot graph of likelihood values
#' '
#' @export
#'
get_mcmc_data <- function(input_folder="",plot_graph=TRUE){
  assert_that(file.exists(input_folder))
  setwd(input_folder)

  file_list=list.files(pattern="*.csv")
  input_frame=data.frame()
  for(i in 1:length(file_list)){
    data=read.csv(file_list[i],header=TRUE)
    input_frame<-rbind(input_frame,data)
  }

  if(plot_graph==TRUE){
    matplot(x=c(1:nrow(input_frame)),y=input_frame$posterior_current,type="l",xlab="Iteration",ylab="LogLikelihood")}

  return(input_frame)
}
#-------------------------------------------------------------------------------
#' @title truncate_mcmc_data
#'
#' @description Take MCMC results generated by get_mcmc_data and extract selected lines; optionally plot likelihood
#' graph and/or output data set
#'
#' @details This function takes in a data frame output by the get_mcmc_data() function and outputs a data frame
#' consisting only of the selected lines; it can be used to cut off all pre-burnin points in the Markov chain and/or
#' to obtain a selection of points along part of the chain. A graph of the posterior likelihood values in the
#' truncated data frame can optionally be plotted.
#'
#' @param input_frame Data frame of output data
#' @param selection Vector of line numbers to extract from input_frame
#' @param plot_graph TRUE/FALSE flag indicating whether to plot results graph
#' @param output_data TRUE/FALSE flag indicating whether to output results as data frame
#' '
#' @export
#'
truncate_mcmc_data <- function(input_frame=list(),selection=c(1),plot_graph=TRUE,output_data=TRUE){
  assert_that(is.data.frame(input_frame))
  assert_that(is.integer(selection))

  line_list=c(1:nrow(input_frame))
  input_frame <- cbind(input_frame,line_list)
  input_frame_truncated=input_frame[selection,]

  if(plot_graph==TRUE){matplot(x=selection,y=input_frame_truncated$posterior_current,
                               type="l",xlab="Iteration",ylab="LogLikelihood")}

  return(input_frame_truncated)
}
#-------------------------------------------------------------------------------
#' @title get_mcmc_FOI_R0_data
#'
#' @description Extract spillover force of infection (FOI) and reproduction number (R0) values from MCMC output data
#'
#' @details This function takes in a data frame produced by functions get_mcmc_data() and/or truncate_mcmc_data() and
#' calculates spillover force of infection (FOI) and reproduction number (R0) values for each row in the frame
#' (representing points on the chain) based on the type of fit carried out.
#'
#' @param input_frame Data frame of MCMC output data
#' @param type Type of parameter set (FOI only, FOI+R0, FOI and/or R0 coefficients associated with environmental
#'   covariates); choose from "FOI","FOI+R0","FOI enviro","FOI+R0 enviro"
#' @param enviro_data Data frame of environmental covariate values used to calculate FOI and R0 in MCMC run, by region
#'   (NOTE: the data frame should include only the relevant environmental covariates; any not used in the MCMC fit
#'    should be removed)
#' '
#' @export
#'
get_mcmc_FOI_R0_data <- function(input_frame=list(),type="FOI+R0",enviro_data=list()){
  #TODO - Add assertthat checks
  assert_that(type %in% c("FOI","FOI+R0","FOI enviro","FOI+R0 enviro"))

  n_lines=nrow(input_frame)
  if(type %in% c("FOI enviro","FOI+R0 enviro")){
    n_env_vars=ncol(enviro_data)-1
    env_vars=colnames(enviro_data)[c(2:(n_env_vars+1))]
    regions=enviro_data$adm1
    n_regions=length(regions)
  } else {
    colnames=colnames(input_frame)
    n_regions=0
    for(i in 1:length(colnames)){
      prefix=substr(colnames[i],1,3)
      if(prefix=="FOI"){n_regions=n_regions+1}
    }
  }
  blank=rep(NA,n_regions*n_lines)
  output_frame=data.frame(n_region=as.factor(rep(c(1:n_regions),n_lines)),FOI=blank)
  if(type %in% c("FOI+R0","FOI+R0 enviro")){
    R0=blank
    output_frame=cbind(output_frame,R0)}

  if(type %in% c("FOI enviro","FOI+R0 enviro")){
    if(type=="FOI enviro"){n_params=n_env_vars}
    if(type=="FOI+R0 enviro"){n_params=2*n_env_vars}
    line0=-Inf
    for(j in 1:n_lines){
      line1=input_frame$line_list[j]
      output_lines=((j-1)*n_regions)+c(1:n_regions)
      if(j>1 && line1==line0+1 && input_frame$flag_accept[j]==0){
        output_frame$FOI[output_lines]=output_frame$FOI[output_lines-n_regions]
        if(type == "FOI+R0 enviro"){output_frame$R0[output_lines]=output_frame$R0[output_lines-n_regions]}
        output_frame$FOI[output_lines]=output_frame$FOI[output_lines-n_regions]
      } else {
        params=input_frame[j,c(3:(n_params+2))]
        FOI=R0=rep(0,n_regions)
        for(n_region in 1:n_regions){
          variable_values=as.numeric(enviro_data[n_region,c(2:(n_env_vars+1))])
          FOI[n_region]=sum(variable_values*params[c(1:n_env_vars)])
          if(type == "FOI+R0 enviro"){R0[n_region]=sum(variable_values*params[c(1:n_env_vars)+n_env_vars])}
        }
        output_frame$FOI[output_lines]=FOI
        if(type == "FOI+R0 enviro"){output_frame$R0[output_lines]=R0}
      }
      line0=line1
    }
  } else {
    for(j in 1:n_lines){
      output_lines=((j-1)*n_regions)+c(1:n_regions)
      output_frame$FOI[output_lines]=as.numeric(input_frame[j,c(3:(n_regions+2))])
      if(type=="FOI+R0"){output_frame$R0[output_lines]=as.numeric(input_frame[j,c((n_regions+3):((2*n_regions)+2))])}
    }
  }

  return(output_frame)
}
#-------------------------------------------------------------------------------
#' @title plot_mcmc_FOI_R0_data
#'
#' @description Plot spillover force of infection (FOI) and reproduction number (R0) values from MCMC output data
#'
#' @details This function takes in a data frame of spillover force of infection (FOI) and reproduction number (R0)
#' values calculated from MCMC output data using the get_mcmc_FOI_R0_data() function and plots the values in one of a
#' number of different ways to display the spread of values obtained (box plots, violin plots, simple plots with error
#' bars, and scatter plots of FOI vs R0).
#'
#' @param data_frame Data frame of FOI/R0 values obtained using get_mcmc_FOI_R0_data()
#' @param regions List of region names
#' @param plot_type Type of plots to create (choose from "box","violin","error_bars","scatter")
#' '
#' @export
#'
plot_mcmc_FOI_R0_data <- function(data_frame=list(),regions=c(),plot_type="box"){
  #TODO - Add assertthat checks
  if(is.null(data_frame$R0)==TRUE){
    assert_that(plot_type %in% c("box","violin","error_bars"))
  } else {
    assert_that(plot_type %in% c("box","violin","error_bars","scatter"))
  }

  n_regions=length(regions)
  output_labels=rep(NA,n_regions)
  for(i in 1:n_regions){output_labels[i]=substr(regions[i],1,5)}

  FOI_labels=10^c(-10:1)
  n_region=NULL

  if(plot_type %in% c("box","violin")){
    FOI=NULL
    p_FOI <- ggplot(data=data_frame,aes(x=n_region,y=log(FOI))) + theme_bw()
    if(plot_type=="box"){p_FOI <- p_FOI+geom_boxplot(outlier.size = 0)} else {p_FOI <- p_FOI+geom_violin(trim=FALSE)}
    p_FOI <- p_FOI + scale_x_discrete(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
    p_FOI <- p_FOI + scale_y_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    p_FOI <- p_FOI + theme(axis.text.x = element_text(angle = 90, hjust=1))

    if(is.null(data_frame$R0)==FALSE){
      R0=NULL
      p_R0 <- ggplot(data=data_frame,aes(x=n_region,y=R0)) + theme_bw()
      if(plot_type=="box"){p_R0 <- p_R0+geom_boxplot(outlier.size = 0)} else {p_R0 <- p_R0+geom_violin(trim=FALSE)}
      p_R0 <- p_R0 + scale_x_discrete(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
      p_R0 <- p_R0 + theme(axis.text.x = element_text(angle = 90, hjust=1))
    } else {
      p_R0<-NULL
    }
    output<-list(p_FOI=p_FOI,p_R0=p_R0)
  }

  if(plot_type=="scatter"){
    p_FOI_R0 <- ggplot() + theme_bw()
    p_FOI_R0 <- p_FOI_R0 + scale_x_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    for(i in 1:n_regions){
      subset=data_frame[data_frame$n_region==i,]
      names(subset)[names(subset)=="n_region"]="Region"
      Region=NULL
      p_FOI_R0 <- p_FOI_R0 + geom_point(data=subset,aes(x=log(FOI),y=R0,colour=Region))
    }
    output<-list(p_FOI_R0=p_FOI_R0)
  }

  if(plot_type=="error_bars"){
    blank=rep(NA,n_regions)
    lower=upper=NULL
    summary_frame_FOI=data.frame(n_region=c(1:n_regions),mean=blank,lower=blank,upper=blank)
    if(is.null(data_frame$R0)==FALSE){summary_frame_R0=summary_frame_FOI}
    for(i in 1:n_regions){
      subset=data_frame[data_frame$n_region==i,]
      FOI_CI=CI(subset$FOI)
      summary_frame_FOI$mean[i]=FOI_CI[[2]]
      summary_frame_FOI$lower[i]=FOI_CI[[3]]
      summary_frame_FOI$upper[i]=FOI_CI[[1]]
      if(is.null(data_frame$R0)==FALSE){
        R0_CI=CI(subset$R0)
        summary_frame_R0$mean[i]=R0_CI[[2]]
        summary_frame_R0$lower[i]=R0_CI[[3]]
        summary_frame_R0$upper[i]=R0_CI[[1]]
      }
    }

    p_FOI <- ggplot(data=summary_frame_FOI,aes(x=n_region,y=log(mean))) + theme_bw()
    p_FOI <- p_FOI + scale_x_continuous(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
    p_FOI <- p_FOI + theme(axis.text.x = element_text(angle = 90, hjust=1))
    p_FOI <- p_FOI + scale_y_continuous(name="FOI",breaks=log(FOI_labels),labels=FOI_labels)
    p_FOI <- p_FOI + geom_line(data=summary_frame_FOI,aes(x=n_region,y=log(mean)))
    p_FOI <- p_FOI + geom_errorbar(data=summary_frame_FOI,aes(ymin=log(lower),ymax=log(upper)),width=0.5)

    if(is.null(data_frame$R0)==FALSE){
      p_R0 <- ggplot(data=summary_frame_R0,aes(x=n_region,y=mean)) + theme_bw()
      p_R0 <- p_R0 + scale_x_continuous(name="",breaks=c(1:n_regions),labels=output_labels[c(1:n_regions)])
      p_R0 <- p_R0 + theme(axis.text.x = element_text(angle = 90, hjust=1))
      p_R0 <- p_R0 + geom_line(data=summary_frame_R0,aes(x=n_region,y=mean))
      p_R0 <- p_R0 + geom_errorbar(data=summary_frame_R0,aes(ymin=lower,ymax=upper),width=0.5)
    } else {
      p_R0 <- NULL
    }
    output<-list(p_FOI=p_FOI,p_R0=p_R0)
  }

  return(output)
}
#-------------------------------------------------------------------------------
#' @title plot_mcmc_prob_data
#'
#' @description Plot values of vaccine efficacy and/or reporting probabilities from MCMC output data
#'
#' @details This function takes in a data frame produced by functions get_mcmc_data() and/or truncate_mcmc_data(),
#' calculates the values of additional parameters fitted using the function besides spillover force of infection (FOI)
#' and reproduction number (R0) plots the values in one of a number of different ways to display the spread of values
#' obtained (box plots, violin plots, simple plots with error bars).
#'
#' @param input_frame Data frame of MCMC output data
#' @param plot_type Type of plots to create (choose from "box","violin","error_bars")
#' @param values List of names of parameters to plot (must be parameters appearing in the data)
#' @param margin For plot type "error_bars" only, the margin of the critical interval to display with the error bars,
#'   expressed as a fraction
#' '
#' @export
#'
plot_mcmc_prob_data <- function(input_frame=list(),plot_type="box",values=c("vaccine_efficacy"),margin=0.95){
  assert_that(plot_type %in% c("box","violin","error_bars"))

  n_values=length(values)
  for(i in 1:n_values){assert_that(values[i] %in% colnames(input_frame))}

  data<-input_frame[,colnames(input_frame) %in% values]
  n_lines=nrow(input_frame)
  labels=c(0.001,0.005,0.01,0.05,0.1,0.5,1.0)
  output_frame=data.frame(n_param=as.factor(rep(c(1:n_values),n_lines)),p=rep(NA,n_values*n_lines))
  for(i in 1:n_lines){
    output_lines=((i-1)*n_values)+c(1:n_values)
    output_frame$p[output_lines]=as.numeric(data[i,])
  }

  if(plot_type %in% c("box","violin")){
    n_param=p=NULL
    p_probs <- ggplot(data=output_frame,aes(x=n_param,y=log(p))) + theme_bw()
    if(plot_type=="box"){
      p_probs <- p_probs+geom_boxplot(outlier.size=0)
    } else {
      p_probs <- p_probs+geom_violin(trim=FALSE)}
    p_probs <- p_probs + scale_x_discrete(name="",breaks=c(1:length(values)),labels=values)
    p_probs <- p_probs + scale_y_continuous(name="",breaks=log(labels),labels=labels)
    p_probs <- p_probs + theme(axis.text.x = element_text(angle = 90, hjust=1))
  }
  if(plot_type=="error_bars"){
    blank=rep(NA,n_values)
    lower=upper=NULL
    summary_frame=data.frame(n_value=c(1:n_values),mean=blank,lower=blank,upper=blank)
    for(i in 1:n_values){
      subset=subset(output_frame,as.numeric(output_frame$n_param)==i)
      probs_CI=CI(subset$p)
      summary_frame$mean[i]=probs_CI[[2]]
      summary_frame$lower[i]=probs_CI[[3]]
      summary_frame$upper[i]=probs_CI[[1]]
    }
    n_value=NULL
    p_probs <- ggplot(data=summary_frame,aes(x=n_value,y=log(mean))) + theme_bw()
    p_probs <- p_probs + scale_x_continuous(name="",breaks=c(1:n_values),labels=values)
    p_probs <- p_probs + scale_y_continuous(name="",breaks=log(labels),labels=labels)
    p_probs <- p_probs + geom_line(data=summary_frame,aes(x=n_value,y=log(mean)))
    p_probs <- p_probs + geom_errorbar(data=summary_frame,aes(ymin=log(lower),ymax=log(upper)),width=0.5)
    p_probs <- p_probs + theme(axis.text.x = element_text(angle = 90, hjust=1))

  }

  return(p_probs)
}
